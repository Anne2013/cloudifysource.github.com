---
layout: default
title: Developing Custom Cloud Drivers
category: Developing Cloud Drivers
publish: true
abstract: An overview of how to develop custom cloud drivers
pageord: 200
---

This topic is an overview of how to develop custom cloud drivers. For general information about the Cloudify cloud driver, see "The Cloud Driver":/guide/clouddrivers/cloud_driver.

h2. How does the Cloud Driver Work? (A Technical Overview)

To explain the main cloud driver scenarios, we will use the Openstack cloud driver (@OpenstackCloudDriver@) that extends the @CloudDriverSupport@ base class and implements the @ProvisioningDriver@ interface.

The Cloudify cloud driver (@ProvisioningDriver@ is the Interface Name), has methods corresponding to the following main scenarios:
* *"Bootstrapping a Cloud":#bootstrap*--Allocates machines and installs the Cloudify controller
* *"Installing an Application":#install*--Allocates machines for application services and installs the application's services (including the Cloudify agent). In this scenario, the cloud driver resides on the management machine as part of the Cloudify controller.<h4 class="info">There is also a *Cluster healing* scenario which is treated by Cloudify as being the same as the *Installing an application* scenario.</h4>
* *"Uninstalling an Application":#uninstall*--Stops the application's services and instructs the cloud driver to unininstall the machines used by the services.
* *"Tearing Down a Cloud":#teardown*--Uninstalls all Cloudify machines and components.

h4(info). The cloud driver is a Java POJO that uses a configuration file to define cloud specific attributes and methods. 

h3(#bootstrap). Bootstrapping a Cloud

<img src="/guide/images/clouddrivers/bootstrapping.png"/>

In this scenario, the cloud driver resides on the client machine as no management machines with the Cloudify controller exist. At the Cloudify shell prompt, the user runs the bootstrap command specifying a cloud driver implementation. The cloud driver is instantiated by the shell, and now the shell passes the *Driver Reference* to its configuration object (org.cloudifysource.dsl.cloud.Cloud) by calling the @setConfig@ method.

<script src="https://gist.github.com/2043019.js?file=setConfig.java"></script>

Next, the shell invokes the cloud driver's @startManagementMachines@ method, which in turn calls the cloud's IaaS API (using the API security settings) to get the required management machines. The cloud API returns an array of MachineDetails (org.cloudifysource.esc.driver.provisioning.MachineDetails) with connction details for each of the allocated management machines. The details are used by the shell to connect to the machines and install the Cloudify management components. Finally, Cloudify starts the following Cloudify controller components: ESM(Elastic Service Manager), GSM(General Service Manager), LUS(Lookup Service) and the Management Space. It will also start the web management container and the REST API container.

<script src="https://gist.github.com/2043033.js?file=createServer.java"></script>

h3(#install). Installing an Application

<img src="/guide/images/clouddrivers/installApplication.png"/>

In this scenario, the cloud driver resides on the server machine. Once the controller is instructed to install an application, it instructs the cloud driver to start the number of application machines described in the recipe. To acheive this, the cloud driver first gets the Admin object so that it can report the public IP addresses of the allocated application machines and other details. This is achieved by the controller calling the setAdmin method.
Next, the controller invokes the cloud driver's @startMachine@ method, once for each machine that must be provisioned, until all the required machines are up and running with Cloudify agent registered with the LUS, or until the request times out.

The @startMachine@ uses the following steps:
# Calls the IaaS API
# Polls the API for the machine details
# Pings the machine to makes sure its accessible
# Connects to the machine over SSH
# Installs and starts the following Cloudify agent components: GSA and GSC

The driver gets the machine information from the template attributes (corresponding to the requested template name) defined in the configuration object.

The same scenario will occur if the controller has to compensate for a crashed machine or to rebalance one of the services, as shown in the following diagram:
<img src="/guide/images/clouddrivers/cluster-healing.png"/>

h3(#uninstall). Uninstalling an Application

<img src="/guide/images/clouddrivers/uninstallApplication.png"/>

In this scenario, the cloud driver resides on the server machine. Once the controller is instructed to uninstall a deployed application, it stops the application's services and instructs the cloud driver to unininstall the machines used by the services. This is achieved by the controller calling the cloud driver's @stopMachine@ method, which in turn calls the cloud's IaaS API and instruct it to stop the relevant machines. 

<script src="https://gist.github.com/2043076.js?file=stopMachine.java"></script>

The following snippet shows how to call the cloud's IaaS API:

<script src="https://gist.github.com/2043089.js?file=terminateServerAPI.java"></script>

h3(#teardown). Tearing Down a Cloud

<img src="/guide/images/clouddrivers/tearDown.png"/>

In this scenario, the cloud driver resides on the client machine. At the Cloudify shell prompt, the user runs the tear down command specifying a cloud driver implementation to uninstall the management machines. This is achieved by the controller calling the cloud driver's @stopManagementMachines@ method, which in turn calls the cloud's IaaS API and instruct it to stop the relevant machines.

<script src="https://gist.github.com/2043105.js?file=stopManagement.java"></script>

h2. Setting Up Your Project


p. This section will teach you what you need in your eclipse project

h4. Prepare your Maven pom file

The following sections section are needed in your pom file:
Set the cloudify version property (optional – you can set it directly in the jar dependency element)

<script src="https://gist.github.com/2070735.js?file=version.xml"></script>

Add the jar dependency: 
<script src="https://gist.github.com/2070742.js?file=dependencies.xml"></script>

Add the Clopudify Repository

<script src="https://gist.github.com/2070752.js?file=repo.xml"></script>






h2. Before You Code


p. This section explains how to get what you need from your cloud account – credentials, SSH access etc.


h4. Getting the Security Credentials for API Access


The security credentials you will need to have for the cloud driver are of two kinds:
* The credentials for the Cloud IaaS API calls
* The credentials for accessing a VM with SSH
In some cases you will need the storage credentials as well

For example this is how you would do it with Openstack:
The Openstack administrator will create a user login ID for you.
When you receive your user id, it will be accompanied by an access key and a secret key.
The access key is used in the Cloud driver configuration for the setting “user”.
The secret key should be used to set the “apiKey” setting.
In order to enable SSL, required for bootstrapping the system, generate a key pair with "HybridFox":http://code.google.com/p/hybridfox/
and save it in the cloud driver “upload” directory.
Also, set the “keyFile” property to the name you gave the key pair in the Cloud driver configuration file.

<script src="https://gist.github.com/2042919.js?file=driver_user.groovy"></script>

<img src="/guide/images/clouddrivers/cloud_driver_plugin.png"/>


h4. Getting the right Image and HW for Management

You will need to define HW / SW templates in the Cloud Driver configuration file. One of them will define the management VM. 
Keep In mind the following:
* The management VM must have public IP to be accessed from the internet or other subnets within the organization using HTTP
* The management VM must have SSH access to be installed
* It will require X of disk space and Y GB of RAM memory
* Currently it must be a Linux Image 

h4. Configure the management template


Now you nedd to tweak the Cloud Driver configuration file:
create a template with the image and HW you selected:

<script src="https://gist.github.com/2070794.js?file=templates.groovy"></script>

set the management machine templates to the template you created:

<script src="https://gist.github.com/2070776.js?file=driver.groovy"></script>

h2. Packing and Adding to Cloudify

In order to use your custom cloud driver you need to the following:
# Add your java binaries as jar to <Cloudify>/lib/required
# Add your cloud driver configuration and security certificate under <Cloudify>/tools/cli/plugins/esc as noted in the below diagram

<img src="/guide/images/clouddrivers/cloud_driver_plugin.png"/>